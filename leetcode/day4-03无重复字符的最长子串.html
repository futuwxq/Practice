<script>
    let lengthOfLongestSubstring = function(s) {
        let arr = [],
            max = 0;
        for (let i = 0; i < s.length; i++) {
            let index = arr.indexOf(s[i])
            if (index !== -1) {
                //删除重复元素及其之前的元素
                // 因为splice删除第二个参数是删除的个数，因此index要+1
                arr.splice(0, index + 1);
            }
            arr.push(s[i]);
            max = Math.max(arr.length, max); //每次都来更新max值
        }
        return max;
    }

    // 使用下标来维护滑动窗口
    // var lengthOfLongestSubstring = function(s) {
    //     let index = 0,
    //         max = 0
    //     for (let i = 0, j = 0; j < s.length; j++) {
    //         //比如重复元素是i，截取i+1到j 的元素组成新数组，新数组继续检测有无重复数字
    //         index = s.substring(i, j).indexOf(s[j])
    //         if (index !== -1) { //重复了，index是重复元素的下标
    //             i = i + index + 1 //把 i 定位到重复元素的下一个
    //         }
    //         max = Math.max(max, j - i + 1); // j-i+1 是当前无重复字符串的长度
    //     }
    //     return max
    // }

    // var lengthOfLongestSubstring = function(s) {
    //     let map = new Map(),
    //         max = 0
    //     for (let i = 0, j = 0; j < s.length; j++) {
    //       if(map.has(s[j])) {
    //         i = Math.max(max)
    //       }
    //     }
    // }

    // 哈希表
    // var lengthOfLongestSubstring = function(s) {
    //     const occ = new Set();
    //     const n = s.length;
    //     console.log(1);
    //     let rk = -1, //  右指针
    //         max = 0; //最大长度
    //     for (let i = 0; i < n; i++) {
    //         if (i != 0) { //遇到了重复的字符
    //             // 左指针向右移动一格，移除一个字符，删除了重复的字符
    //             console.log("删除之前", occ);
    //             occ.delete(s.charAt(i - 1));
    //             console.log(occ);

    //         }

    //         while (rk + 1 < n && !occ.has(s.charAt(rk + 1))) {
    //             occ.add(s.charAt(rk + 1)); //不重复的元素加入哈希表

    //             ++rk; // 不断地移动右指针
    //         }
    //         //跳出 while循环 说明 第 rk + 1个字符重复了
    //         // 第 i 到 rk 个字符是一个极长的无重复字符子串
    //         max = Math.max(max, rk - i + 1);
    //     }
    //     return max;
    // }
    var lengthOfLongestSubstring = function(s) {
        let map = new Map()

        max = 0
        for (let i = 0, j = 0; j < s.length; j++) {
            if (map.has(s[j])) {
                console.log(map.get(s[j]));
                console.log(map.get(s[j]) + 1);
                // i 是重复元素的的下一个元素的下标 这里也就是滑动窗口的左侧移动到重复元素的下一个元素
                i = Math.max(map.get(s[j]) + 1, i)
            }
            max = Math.max(max, j - i + 1)
            console.log("max", max)

            console.log("之前", map)
            map.set(s[j], j)
            console.log("之后", map)

        }
        return max
    };
    s = "abcbcbb";
    lengthOfLongestSubstring(s);

    // 暴力解法{
    for (let i = 0; i < s.length; i++) {
        let j = i + 1;

    }
</script>